###### 基本类型有八种，都是Java语言预先定义好的关键字，分别是整型（4种），字符型（1种），浮点型（2种），布尔型（1种）
### 1. 说出这八种基本数据类型
>整型：byte、short、int、long
>字符型：char
>浮点型：float、double
>布尔型：boolean
### 2. 说出四种整型数据类型占用的字节数和表示范围
>- byte：占用1个字节（8位），表示范围是 -128 ~ 127.
>-  short：占用2个字节（16位），表示范围是 -32768 ~ 32,767.
> - int：占用4个字节（32位），表示范围是 -2147483648 ~ 2147483647.
>-  long：占用8个字节（64位），表示范围是 -9223372036854775 808 ~ 9223372036854775807。<u>****在数值后面加上 L 或 l 来表示这是一个 long 类型的字面量。(一般加L,个人感觉大写可以和1区分开来)****</u>
### 3.请回答这个过程涉及到的是自动类型转换还是强制类型转换，b的值是多少，为什么会是这个值
>int a=4;
>char c='0';
>int b=a+c;

**答:自动类型转换;  ~~b = 40 ;c 是字符类型的数据,参与计算时,发生的是"拼接",所以 b 等于整数类型数据a后面拼接一个数字0,即b的值为40.~~***(蚌埠住了,把char和String搞混了)*
**b = 52 ;**
**char类型数据在运算时会将对应字符根据ACII码表转化为int类型数据,再参与运算,此过程为自动类型转换(也叫隐式转换).而0在ACII码表上对应的数为48(a是97,A是65,其他的字母可以根据这俩推),a与c两个都是int类型数据(其中c在运算过程中发生了自动类型转换),所以b也是int类型数据,且 b = a + c = 4 + 48 = 52.**
### 4.请了解包装类，引用类型和基本数据类型缓存池。给出下面代码的输出结果并解释原因。
```
Integer x = new Integer(18);
Integer y = new Integer(18);
System.out.println(x == y);
Integer z = Integer.valueOf(18);
Integer k = Integer.valueOf(18);
System.out.println(z == k);
Integer m = Integer.valueOf(300);
Integer p = Integer.valueOf(300);
System.out.println(m == p);
```
![alt text](<屏幕截图 2024-10-20 152023.png>)
-   输出结果: false true false
-   原因解释:
    -   对于Integer类,JVM维护了一个缓存池,用于缓存-128到127(包括-128和127)之间的Integer对象.当使用Integer.valueOf()方法并且参数在这个范围内时，**<u>实际上是从缓存池中返回一个已经创建的实例，而不是每次都创建一个新的对象。</u>**
    -   第一个false,是因为x和y是通过new关键字创建的两个不同的对象,所以x!=y;
    -   第二个true,是因为z和k都等于18,都在参数范围内,且都是通过*valueOf()方法*从缓存池中获取的同一个对象,所以z = k ;
    -   第三个false,是因为m和p都等于300,超出了JVM用于维护Integer类的缓存池的参数范围,因此都是通过*valueOf()方法* 新创建的对象，不是同一个对象,所以m ! = p.
### 5. 算数运算符除了我们熟知的加减乘除（+ - * /）外，还有取余（%），自增（++），自减（--）。为了加深你对于自增运算符的理解，请执行下列代码，给出结果，并大概解释计算的过程。
```
int a = 5 ;
int b = 7 ;
int c= (++a) + (b++)
System.out.println( c );
System.out.println(a+" "+b);
```
![alt text](<屏幕截图 2024-10-20 111418.png>)
***c = 13 ;  a+" "+b = 6 8 ;***
*大概解释计算的过程:*
*++a在参与运算时,是先自增后用,b++则是先用再自增,所以c = (1+5) + 7 =13; a + " " + b = 6 + 8 ;*
### 6.请了解补码。
#### 若a=0010(二进制),说出 a&(-a) 的二进制形式是什么。对于任意的非负整数a,式子a&(-a)表示的数是什么，为什么得到这个结果（不用严格证明）。
**其实这是一个著名的函数lowbit,应用之一就是树状数组。**
-   若a=0010(二进制),说出 a&(-a) 的二进制形式是什么
     -    a&(-a) = 0010 (二进制形式)
-   对于任意的非负整数a,式子a&(-a)表示的数:
    -   对于任意非负整数 a,表达式 a & (-a) 总是a在二进制表示下 “ **最低位的 1** 及其后面的所有的 0 ” 的二进制构成的数值.<u>就比如10的二进制为1010,**最低位的1**及其后面的0组成的二进制数值为10,即 *lowbit ( 10 ) = 2*</u>
    -   在二进制中,a 和 -a 进行按位与操作时，只有 a **最低位的1**会保留,因为 -a 的二进制表示中,除了最低位的1,其他位都是0。所以 a & (-a) 的结果就是 a 的**最低位的1**及其后面的0组成的二进制数值.

### 7. 请说出float 和 double两种浮点型数据的表示范围,并给出你的计算过程。
>#### float表示范围
>- **最小正非零值**：
  \[ 2^{-126} \approx 1.4 \times 10^{-45} \]
>- **最大值**：
  \[ (2 - 2^{-23}) \times 2^{127} \approx 3.4 \times 10^{38} \]
>--------------------------
>#### double表示范围
>- **最小正非零值**：
  \[ 2^{-1022} \approx 5.0 \times 10^{-324} \]
>- **最大值**：
  \[ (2 - 2^{-52}) \times 2^{1023} \approx 1.8 \times 10^{308} \]

### 8.请了解String的底层实现,给出下面代码的输出，并解释原因
```
public class Test {
 
 public static void main(String[] args) {
 Test t1 = new Test();
 String s = "hello";
 t1.append(s);
 System.out.println("main: " + s);
 
 }
 
 private void append(String s) {
 s += " world";
 System.out.println("method: " + s);
 }
}
```
![alt text](<屏幕截图 2024-10-20 195106.png>)
-   输出:
    -   method: hello world
    -   main: hello
-   原因解释:<u>String 类是不可变的，这就意味着任何对 String 对象的修改都会创建一个新的 String 对象。</u>在这串代码中,append 方法尝试修改传入的 String 对象 s，但由于 String 的不可变性，这个修改实际上创建了一个新的 String 对象，所以在 append 方法里面的那个对象 s 是个新的 s ,而原始的 s 对象在 main 方法中没有被改变。因此 append 方法里面输出的是  **method: hello world**,里面的s是新的对象;而 main 方法里面输出的是 **main: hello**,里面的s是原来的.



