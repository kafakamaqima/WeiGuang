### 1. 请了解if-else相关知识。补全下面的函数：
```
//这个函数用于判断传入的年份是否为闰年
//是闰年返回1,不是闰年返回2
bool isLeapYear(int year){
}
```
>-   如果年份能被4整除但不能被100整除,则为闰年。
>-   如果年份能被400整除,也是闰年。
-   函数补全:  
```
bool isLeapYear(int year){
    if((year % 4 == 0 && year % 100 !=0)||(year % 400 ==0)){
        return 1;
    }else{
        return 2;
    }
}
```
### 2. 请了解for-while相关知识。补全下面函数:
```
//这个函数打印一个高度为n的空心菱形，保证n为奇数
//如n=5,则打印如下图形：
//  *
// * *
//*   *
// * *
//  *
void print(int n){
}
```
-   函数补全: 
```
void print(int n){
int half = n/2;
        for (int i = 1; i <= half; i++) {//上半
            for (int j = 1; j <= half - i; j++) {
                System.out.print(" ");
            }
            for (int z = 1; z <= 2 * i - 1; z++) {
                if (z == 1 || z == (2 * i - 1)) {
                    System.out.print("*");
                } else {
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
        for (int i = half - 1; i >= 1; i--) {//下半
            for (int j = 1; j <= half - i; j++) {
                System.out.print(" ");
            }
            for (int z = 1; z <= 2 * i - 1; z++) {
                if (z == 1 || z == (2 * i - 1)) {
                    System.out.print("*");
                } else {
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
}
```
### 3. 汉诺塔
>#### 通过if-else,for等等能够对程序进行简单的流程控制,而实际上,还有一种很重要的方式——递归。请了解汉诺塔问题,下面的问题即是基于汉诺塔。现在有A,B,C三个柱子,在A柱上有n块铁饼,现在要把A柱上的n块铁饼都移动到C柱上,请补全函数，使得函数打印出移动的过程。要求给出你代码的具体思路，可以写在文档或者代码注释中
```
//当n=3时,函数应该打印如下内容：
//A->C  (A->C的意思是把A柱最上方的铁饼移动到C柱上,以下同理)
//A->B
//C->B
//A->C
//B->A
//B->C
//A->C
void hanoi(int n){
 
}
```
- **递归: 在编程中，一个方法（或函数）可以调用它自己，这种技术被称为递归。递归是一种在编程中解决问题的方法，其中方法会调用自身来重复执行任务，直到满足某个条件（基本情况）为止。**
- ***本题的递归,采用的是分而治之的算法,将一个复杂的问题拆分为很多个简单重复的小问题(即看做最低层的盘子与将其上面的盘子看成一个整体的大盘子两个盘子的子问题)再一个个子问题一直递归下去解决,直至达到基本情况(n = 1)停止.***
```
package com.niganma.demo;
//详细代码见WeiGuang\Java02\untitled1\Task\src\com\niganma\demo\copyHanoiTower.java
import java.util.Scanner;

public class copyHanoiTower {
    public static void main(String[] args) {
        copyHanoiTower hanoiTower = new copyHanoiTower();
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入一个正整数");
        int n = sc.nextInt();//键盘录入一个正整数,测试不同数量盘子发生的情况
        // 调用hanoi方法时，需要传递四个参数：盘子的数量和三个柱子的标识符
        hanoiTower.hanoi(n, 'A', 'C', 'B');
    }

    /**
     * 打印汉诺塔的移动过程
     *
     * @param n    盘子的数目
     * @param from 起始柱子
     * @param to   目标柱子
     * @param aux  辅助柱子
     */
    public void hanoi(int n, char from, char to, char aux) {
        if (n == 1) {
            System.out.println(from + "->" + to);
            //此为基本情况,有了基本情况,递归就有停止的条件
        } else {
            //1. 将源柱子上的顶部n-1个盘子移动到辅助柱子上
            hanoi(n - 1, from, aux, to);
            //2. 将源柱子上剩下的最大盘子移动到目标柱子上
      /*此过程是参数为n的时候,操作的是最底下的盘子,与调用的hanoi方法里
      的n-1不同.我们在每次递归调用时将问题规模减小，即从 n 减少到 n-1。这意
      味着在递归的每一层，我们都在处理更少的盘子。但是，我们并不是在 else 块
      中忽略最下面的大盘子，而是在每次递归调用中重新定义柱子的角色，以确保大盘
      子能够被正确地移动。*/
            System.out.println(from + "->" + to);
            //3. 将辅助柱子上的n-1个盘子移动到目标柱子上，覆盖在最大盘子之上
       /*在调用递归方法的过程中,形参'A''C''B'的位置并没有发生变化,而是通
       过每次递归调用中重新分配 from、to 和 aux 参数的角色，以实现盘子的移动*/
            hanoi(n - 1, aux, to, from);
        }
    }
}
```
### 4. 归并排序
>#### 归并排序是一种高效的，基于比较的，稳定的排序算法。归并排序的思路是，把待排序的序列平分成两个子序列，将两个子序列分别进行归并排序后（提示：这里就是递归思想的体现），得到两个有序的子序列，再把这两个有序的子序列合并成有序的序列，就完成了排序。请了解归并排序，并补全以下的函数。要求给出你代码的具体思路，可以写在文档或者代码注释中
```void mergeSort(int[] nums)```




### 5. 瑞士轮
>##### 这个题目需要你写一个完整的程序，而不再是补全函数，所以你需要接收输入。而且要求给出你代码的具体思路，可以写在文档或者代码注释中
>-  题目背景
>在双人对决的竞技性比赛，如乒乓球、羽毛球、国际象棋中，最常见的赛制是淘汰赛和循环赛。前者的特点是比赛场数少，每场都紧张刺激，但偶然性较高。后者的特点是较为公平，偶然性较低，但比赛过程往往十分冗长。本题中介绍的瑞士轮赛制，因最早使用于1895年在瑞士举办的国际象棋比赛而得名。它可以看作是淘汰赛与循环赛的折中，既保证了比赛的稳定性，又能使赛程不至于过长。
>-  题目描述
2×N名编号为 1~2N 的选手共进行R 轮比赛。每轮比赛开始前，以及所有比赛结束后，都会按照总分从高到低对选手进行一次排名。选手的总分为第一轮开始前的初始分数加上已参加过的所有比赛的得分和。总分相同的，约定编号较小的选手排名靠前。每轮比赛的对阵安排与该轮比赛开始前的排名有关：第1 名和第2 名、第 3 名和第 4名、……、第2K - 1 名和第 2K名、…… 、第2N - 1 名和第2N名，各进行一场比赛。每场比赛胜者得1 分，负者得 0 分。也就是说除了首轮以外，其它轮比赛的安排均不能事先确定，而是要取决于选手在之前比赛中的表现。现给定每个选手的初始分数及其实力值，试计算在R 轮比赛过后，排名第 Q 的选手编号是多少。我们假设选手的实力值两两不同，且每场比赛中实力值较高的总能获胜。
>-   输入格式
第一行是三个正整数N,R ,Q,每两个数之间用一个空格隔开，表示有 2×N 名选手、R 轮比赛，以及我们关心的名次 Q。
